

--- Moonlight interactive fiction world simulator.
--
-- Local functions are used internally by the simulator and not meant
-- to be called directly.
--
-- See @{getting_started.lua} for a quick introduction.
--
-- @module moonlight

------------------------------------------------------------------------

--- A table of the parsed sentence, and world items that match any nouns.
-- @table command
--
-- @field verb
-- The verb word as interpreted by the parser.
-- It may mutate into a root word if the player input a synonym.
--
-- @field nouns
-- Indexed table of noun words parsed from the sentence.
-- It is not guaranteed these nouns match any items visible to the player.
--
-- @field direction
-- The word of the direction implied in the sentence.
--
-- @field item1
-- The world item (table) that matches the first of the nouns field.
-- If this has a value it is guaranteed to match an item in the world.
--
-- @field item2
-- The world item (table) that matches the second of the nouns field.
-- If this has a value it is guaranteed to match an item in the world.
--

------------------------------------------------------------------------

--- List of responses generated by a turn.
-- And example response is:
-- {"You take the envelope", "It feels like there is something heavy inside it"}
-- @table responses


------------------------------------------------------------------------

--- A thing that exists in the simulated world.
-- @table thing
--
-- @field name
-- The name of the thing
--
-- @field description
-- The detailed description of the thing when it is examined.
-- If not set a generic description is generated.
--
-- @field person
-- A boolean indicating the thing is a person.
-- The default article rule is ignored when the person is listed.
--
-- @field article
-- Optional article used to prefix the thing's description.
-- If not given the article will default to "a" or "an" depending
-- on vowel rules. To list the thing as plural set the article to
-- "some" or any similar text.
--
-- @field fixed
-- The thing is fixed in place, meaning the player cannot take it.
--
-- @field contains
-- Index table of other things that is carried. If not specified then
-- this thing cannot carry anything.
--
-- @field supports
-- Index table of other things supported (i.e. on top of) this thing.
-- If not specified then this thing cannot support other things.
--
-- @field edible
-- A boolean indicating the thing is edible by the player.

------------------------------------------------------------------------

--- Defines behavior for performing actions during simulation.
-- @table rule
--
-- @field name
-- The name of the rule.
--
-- @field action
-- A function defining the rule logic. It receives (@{moonlight:instance}, @{moonlight:command})
-- as parameters.
-- The action can return up to 2 values.
-- The first return value is the response text.
-- The second return value is a boolean false indicating failure.
-- Further rulebook processing stops if the rule fails.

------------------------------------------------------------------------

--- A table of options that define parser and response behavior.
-- @table options
--
-- @field verbs
-- Indexed table of words considered valid verbs.
-- If the player tries using a verb not in this list
-- then the defaultResponses.unknownVerb response is issued.
--
-- @field ignores
-- Indexed table of words to ignore when parsing a sentence.
-- These are words not considered verbs or nouns.
--
-- @field synonyms
-- Indexed table of tables of words. The first word is the root word and
-- following words are the synonyms. When a sentence is parsed all words
-- are replaced by their root equivalent.
--
-- @field vowels
-- Indexed table english vowels, used to generate noun articles when
-- describing or listing things.
--
-- @field directions
-- Indexed table of known directions.
--
-- @field auto
-- @{moonlight.auto} options that set automatic responses to certain actions.
--
-- @field soundex
-- A boolean to enable soundex matching of known nouns to the player's
-- input during sentence parsing.
local options = {
	verbs = { "examine", "take", "drop", "attack",
		"inventory", "insert", "go", "open", "close" },
	ignores = { "an", "a", "the", "for", "to", "at", "of",
		"with", "about", "on", "and", "from", "into" },
	synonyms = {
		{ "attack", "hit", "smash", "kick", "cut", "kill" },
		{ "insert", "put" },
		{ "take", "get", "pick" },
		{ "inventory", "i" },
		{ "examine", "x", "l", "look" },
		{ "north", "n" },
		{ "south", "s" },
		{ "east", "e" },
		{ "west", "w" },
		{ "northeast", "ne" },
		{ "southeast", "se" },
		{ "northwest", "nw" },
		{ "southwest", "sw" },
		{ "in", "inside" },
		{ "out", "outside" }
	},
	vowels = {"a", "e", "i", "o", "u"},
	directions = {
		"n","north",
		"s","south",
		"e","east",
		"w","west",
		"ne", "northeast",
		"se", "southeast",
		"nw", "northwest",
		"sw", "southwest",
		"up",
		"down",
		"in", "inside",
		"out", "outside"
		},

	--- A table of boolean options that set automatic responses to certain actions.
	-- See the link to the source for all the available options.
	-- @table auto
	-- @field key true/false
	-- @usage auto["describe exits"] = true
	auto = {
		-- list all exits after the room description
		["describe exits"] = false,
		-- list the contents of a container when opening it
		["list contents of opened"] = false
	},
	verbose = {
		rulebooks = true,
		parser = true
	}
}

--- List of standard responses.
-- See the link to the source for the template wording.
-- @table template
local templateResponses = {
	alreadyClosed = "The %s is already closed.",
	alreadyHaveIt = "You already have it.",
	alreadyOpen = "The %s is already open.",
	closed = "You close the %s.",
	containerLead = "Inside it is %s.",
	darkroomDescription = "You are in the dark.",
	dontHaveIt = "You don't have the %s.",
	dropped = "You drop the %s.",
	fixedInPlace = "The %s is fixed in place.",
	insertIn = "You put the %s in the %s.",
	insertOn = "You put the %s on the %s.",
	missingFirstNoun = "You need to tell me what you want to %s",
	missingSecondNoun = "You need to tell me where you want to %s the %s.",
	noExits = "The room %q does not have exits defined, you can never leave!",
	noExitThatWay = "You cannot go that way.",
	notCloseable = "The %s cannot closed.",
	notContainer = "You can't put things in %s.",
	notOpenable = "The %s cannot be opened.",
	notSupporter = "You can't put things on %s.",
	opened = "You open the %s.",
	pocketsEmpty = "You are carrying nothing.",
	roomLead = "There is %s here.",
	supporterLead = "On it is %s.",
	taken = "You take the %s.",
	takePerson = "%s wouldn't like that.",
	tooDarkForThat = "It is too dark to do that.",
	unknownNoun = "I don't see the %s.",
	unknownVerb = "I don't know what %q means.",
	verbMissingNouns = "Be a little more specific what you want to %s.",
	whichDirection = "I can't tell which direction you want to go, N, S, E or W?",
}

local utils = require("utils")
local parse = require("parser")

--- Test if the command object refers to all things.
-- @return boolean
local function commandRefersAll (self, command)
	return (not command.item1) and (command.nouns[1] == "all")
end


--- Increment the number of times a noun has been verbed.
local function countVerbUsedOnNoun (self, command)
	if command.item1 then
		command.item1.count = command.item1.count or { }
		command.item1.count[command.verb] = (command.item1.count[command.verb] or 0) + 1
	end
end


--- Builds the standard set of rulebooks.
local function standardRulebooks ()

	local rulebooks = {
		["before"] = { }, -- before action rules
		["on"] = { }, -- action rules
		["after"] = { }, -- after action rules
		["turn"] = { }, -- rules for before and after turns
	}

	require("take_rules")(rulebooks)
	require("drop_rules")(rulebooks)
	require("examine_rules")(rulebooks)
	require("going_rules")(rulebooks)
	require("inventory_rules")(rulebooks)
	require("insert_rules")(rulebooks)
	require("open_rules")(rulebooks)
	require("close_rules")(rulebooks)
	require("turn_rules")(rulebooks)

	return rulebooks

end


--- TODO
local function reset (self)
	self.rulebooks = standardRulebooks()
	self.player = nil
	self.room = nil
end


--- Test if the command passes checks in rulebook.
--
-- @param self
-- @{instance}
--
-- @param book
-- The rulebook to test against.
--
-- @param command
-- The @{command} to validate.
--
-- @return boolean
local function referRulebook (self, book, command)

	if not book then
		return true
	end

	local rules

	if type(command) == "string" then
		-- if this is a non-action rulebook
		rules = book[command]
		command = { verb = command }
	else
		-- this is an action rulebook
		rules = book[command.verb]
	end

	if not rules then
		return true
	end

	for _, rule in ipairs(rules) do

		if type(rule.action) == "function" then

			local message, result = rule.action(self, command)

			if self.options.verbose.rulebooks then
				table.insert (self.log,
				string.format("Consulted the %q rulebook on the %q topic: %s",
					rule.name, command.verb, (result == false) and "fail" or "pass"))
			end

			if message then
				table.insert (self.responses, message)
			end

			-- a failed rule stops immediately
			if result == false then
				return false
			end

		end

	end

	return true

end


--- Search for an item in a specific parent item.
-- @param self
--
-- @param term
-- The thing to search for, either by the name or by an instance of the
-- thing itself.
--
-- @param parent
-- The parent container to search within. Usually this is the current
-- room, but can also be the player for inventory checking, or any other
-- world item.
--
-- @param stack
-- Ignore this parameter, it is used to track the search progress
-- internally, and only given a value as part of the recursive function.
--
-- @return item @{thing}, parent @{thing}, index
local function search (self, term, parent, stack)

	-- can search by name or by item
	local isItemSearch = type(term) == "table"

	-- init searched table stack
	stack = stack or { }
	local vessel = nil
	local vesselType = nil

	if type(parent.contains) == "table" and not stack[parent.contains] then
		--print(tostring(parent.name) .. " is a container")
		vessel = parent.contains
		vesselType = "container"
	elseif type(parent.supports) == "table" and not stack[parent.supports] then
		--print(tostring(parent.name) .. " is a supporter")
		vessel = parent.supports
		vesselType = "supporter"
	end

	if vessel then

		-- search in teh current vessel
		for i, v in ipairs(vessel) do
			if isItemSearch then
				if v == term then
					return v, parent, i, vesselType
				end
			else
				if string.lower(tostring(v.name)) == term then
					--print("found " .. tostring(term) .. " in " .. tostring(parent.name) .. "!")
					return v, parent, i, vesselType
				end
			end
		end

		-- push new vessels (children of the current) on the search stack
		for k, v in ipairs(vessel) do
			-- TODO this might cause bugs if the item is both a supporter and a container.
			-- stack only tracks the searched space for one of those cases.
			-- Possibly fix by concating both sets into the vessel table?
			if not stack[v] and (type(v.contains) == "table" or type(v.supports) == "table") then
				--print("looking inside " .. tostring(v.name))
				stack[v] = true
				local resv, resp, resi, rest = search(self, term, v, stack)
				if resv then
					return resv, resp, resi, rest
				end
			end
		end

	end

end



--- Search the world for a thing.
-- @param self
--
-- @param term
-- The thing to search for, either by the name or by an instance of the
-- thing itself.
--
-- @return @{search} results.
local function searchGlobal (self, term)

	if type(self.world) ~= "table" then
		error ("The world is empty")
	end

	for _, v in pairs(self.world) do
		local item, parent, i = search (self, term, v)
		if item then
			return item, parent, i
		end
	end

end


--- Set the player character in the world simulation.
-- @function setPlayer
-- @param self
-- @param name
-- The name of the player character.
local function setPlayer (self, name)

	-- unassign the current player
	if self.player then
		self.player.isPlayer = nil
	end

	self.player, self.room = searchGlobal (self, string.lower(tostring(name)))

	if not self.player then
		error(string.format("I could not find a thing named %q.", name))
	end

	if not self.room then
		error(string.format("The thing named %q is not a child of a room.", name))
	end

	-- ensure the player can carry things
	self.player.contains = self.player.contains or { }

	self.player.isPlayer = true

end


--- Set the world model.
local function setWorld (self, world)
	-- ensure all rooms can contain things
	for _, room in ipairs(world) do
		room.contains = room.contains or { }
	end
	self.world = world
	local valid, issues = self:validate (world)
	return valid, issues
end


--- Get the name of an item with the article prefixed.
local function withArticle (self, item)

	if item.person == true then
		-- TODO include article with the person
		return item.name
	end

	if item.article then
		return string.format("%s %s", item.article, item.name)
	end

	if utils.indexOf(self.options.vowels, string.sub(item.name, 1, 1)) == 0 then
		return string.format("a %s", item.name)
	else
		return string.format("an %s", item.name)
	end

end


--- Joins an array of items to read naturally.
-- It joins a list of names with commas or "and" depending on how
-- many names are listed.
local function joinNames(self, names)

	if #names == 2 then
		return table.concat(names, " and ")
	elseif #names > 2 then
		local lastitem = table.remove(names)
		return table.concat(names, ", ") .. " and " .. lastitem
	else
		return table.concat(names)
	end

end


--- Lists the contents of a container or supporter.
--
-- @param self
--
-- @param item
-- The item that will be described
--
-- @param leadFormat
-- The description format which can vary for rooms vs containers.
--
-- @return string
local function listContents (self, item, leadFormat)

	-- list all the items contained in the item, or on top of the item.
	local items = { }
	local containerText = nil
	local supporterText = nil

	-- TODO refer rulebook on listing things
	--local listClosed = referRulebook (self, self.rulebooks["listing"], "container")

	if type(item.contains) == "table" and not item.closed then
		for k, v in pairs(item.contains) do
			if not v.isPlayer then
				table.insert(items, withArticle(self, v))
			end
		end
		-- TODO test if item.isRoom and use the room lead instead of taking this parameter
		if #items > 0 then
			containerText = string.format(leadFormat or self.template.containerLead, joinNames(self, items))
		end
	end

	-- clear items list for supporter listing
	items = { }

	-- list things on top of the item
	if type(item.supports) == "table" then
		for k, v in pairs(item.supports) do
			table.insert(items, withArticle(self, v))
		end
		if #items > 0 then
			supporterText = string.format(self.template.supporterLead, joinNames(self, items))
		end
	end

	if containerText and supporterText then
		return string.format("%s %s", containerText, supporterText)
	elseif containerText then
		return containerText
	elseif supporterText then
		return supporterText
	end

end


--- Describe the given item in detail.
-- The item's description is generated if it has none defined.
--
-- @param self
--
-- @param item
-- The item that will be described
--
-- @param leadFormat
-- The description format which can vary for rooms vs containers.
--
-- @return string
local function describe (self, item, leadFormat)

	-- default item description if none is specified
	local desc = item.description or string.format("It is a %s.", item.name)

	-- TODO test if item.isRoom and use the room lead instead of taking this parameter
	local contents = listContents (self, item, leadFormat)

	if item.closed == true then
		desc = string.format("%s %s", desc, "It is closed.")
	end

	if contents then
		return string.format("%s %s", desc, contents)
	else
		return desc
	end

end

--- Describe room.
local function describeRoom (self)

	return describe (self, self.room, self.template.roomLead) .. self:listRoomExits()

end


--- List exits in a room.
local function listRoomExits (self)

	-- always list exits in a dark room
	local darkroom = self.room.dark and not self.room.lit

	if self.options.auto["describe exits"] or darkroom then
		if type(self.room.exits) == "table" then
			local possibleWays = { }
			for k, v in pairs(self.room.exits) do
				table.insert(possibleWays, k)
			end
			if #possibleWays > 0 then
				table.sort(possibleWays)
				return " You can go " .. joinNames(self, possibleWays) .. "."
			end
		end
	end

	return ""

end


--- Lists items carried by the player.
-- @return string
local function listInventory (self)

	if #self.player.contains == 0 then
		return self.template.pocketsEmpty
	end

	local items = { }

	for _, v in pairs(self.player.contains) do
		table.insert (items, withArticle (self, v))
	end

	return string.format ("You are carrying %s.", joinNames (self, items))

end


--- Move an item into a container.
--
-- @param self
-- @{instance}
--
-- @param item
-- The @{thing} to move.
--
-- @param target
-- The new parent, the @{thing} to move item to.
local function moveItemInto (self, item, target)

	if not type(item) == "table" then
		error ("no item specified to move")
	end

	if not type(target) == "table" then
		error ("no target specified to move the item to")
	end

	local isContainer = type(target.contains) == "table"

	if not isContainer then
		table.insert(self.responses, string.format(self.template.notContainer, target.name))
		return false
	end

	-- find the current parent of the item
	local match, parent, idx, vesselType = search(self, item, self.room)

	if match and target and parent then
		if vesselType == "container" then
			table.remove(parent.contains, idx)
		elseif vesselType == "supporter" then
			table.remove(parent.supports, idx)
		end
		table.insert(target.contains, match)
	end

	return true

end


--- Move an item on top of a supporter.
--
-- @param self
-- @{instance}
--
-- @param item
-- The @{thing} to move.
--
-- @param target
-- The new parent, the @{thing} to move item to.
local function moveItemOnto (self, item, target)

	if not type(item) == "table" then
		error ("no item specified to move")
	end

	if not type(target) == "table" then
		error ("no target specified to move the item to")
	end

	local isSupporter = type(target.supports) == "table"

	if not isSupporter  then
		table.insert(self.responses, string.format(self.template.notSupporter, target.name))
		return false
	end

	-- find the current parent of the item
	local match, parent, idx, vesselType = search(self, item, self.room)

	if match and target and parent then
		if vesselType == "container" then
			table.remove(parent.contains, idx)
		elseif vesselType == "supporter" then
			table.remove(parent.supports, idx)
		end
		table.insert(target.supports, match)
	end

	return true

end


--- Test if the player is carrying an item.
local function playerHas (self, item)

	return search(self, item, self.player) ~= nil

end


--- Get a list of children, contained or supported, by an item.
local function listChildrenOf (self, item)

	local list = { }

	if type(item.contains) == "table" then
		for _, v in pairs(item.contains) do
			table.insert(list, v)
		end
	end

	if type(item.supports) == "table" then
		for _, v in pairs(item.supports) do
			table.insert(list, v)
		end
	end

	return list

end


--- Get a room by name.
local function roomByName (self, name)
	name = string.lower(name)
	for _, r in pairs(self.world) do
		if string.lower(r.name) == name then
			return r
		end
	end
end


--- Get the room adjoining the current by direction
local function roomByDirection (self, direction)
	local way = self.room.exits[direction]
	if not way then
		return
	end
	return roomByName (self, way)
end


--- Apply a command to a world model.
-- This forwards the simulation by performing the command action against
-- the command nouns.
--
-- @return boolean
-- If the action succeeded.
local function apply (self, command)

	-- call "before" rules
	-- explicit false results stops further processing
	if referRulebook (self, self.rulebooks["before"], command) == false then
		return false
	end

	-- call "on" rules
	referRulebook (self, self.rulebooks["on"], command)

	-- call "after" rules
	referRulebook (self, self.rulebooks["after"], command)

	countVerbUsedOnNoun (self, command)

end


--- Calls a predefined hook that was defined by you, for the given
-- noun/verb combination of the command.
--
-- @param self
-- @param command
-- The @{command} object to check for hook existence.
local function callHook (self, command)

	-- Call any hooks for the verb and noun
	if type(self.api.hooks[command.verb]) == "table" then

		local noun = command.nouns[1]
		local hook = self.api.hooks[command.verb][noun]

		if type(hook) == "function" then
			return hook(self, command)
		end

	end

end


--- List the nouns in the current room.
-- Used to assist the parser in noun lookup.
local function listNouns (self)

	local checklist = { }
	local nounlist = { }

	for k, r in pairs(self.room.contains) do
		table.insert(checklist, r)
	end

	while #checklist > 0 do

		local v = table.remove(checklist)
		table.insert(nounlist, v.name)

		if type(v.contains) == "table" then
			for a, b in pairs(v.contains) do
				table.insert(checklist, b)
			end
		end
		if type(v.supports) == "table" then
			for a, b in pairs(v.supports) do
				table.insert(checklist, b)
			end
		end

	end

	return nounlist

end


--- Process the player's turn.
-- The sentence is parsed into actionable verbs and nouns, those are
-- applied to the world model and a response is generated.
--
-- @function turn
--
-- @param self The moonlight instance.
--
-- @param sentence The input sentence that is parsed into actions.
--
-- @return @{responses}, @{command}
local function turn (self, sentence)

	-- Clear the previous turn responses
	self.responses = { }
	self.log = { }

	-- TODO: boil the room down
	-- copy the room object but only include items visible.
	-- do not mutate the original room contents.

	if referRulebook (self, self.rulebooks["turn"], "before") == false then
		return
	end

	-- list of known nouns from the current room
	local known_nouns = listNouns(self)

	-- Parse the sentence
	local command = parse (sentence, {
		known_nouns = known_nouns,
		directions = self.options.directions,
		ignores = self.options.ignores,
		synonyms = self.options.synonyms,
		soundex = self.options.soundex
		})

	if self.options.verbose.parser then
		table.insert(self.log, string.format("Parsed verb as %s", tostring(command.verb)))
		table.insert(self.log, string.format("Parsed noun as %s", tostring(command.nouns[1])))
		table.insert(self.log, string.format("Parsed noun as %s", tostring(command.nouns[2])))
	end

	-- Do we understand the verb?
	if not utils.contains (self.options.verbs, command.verb) then
		table.insert(self.responses, string.format(self.template.unknownVerb, command.verb))
		return command
	end

	-- look up each noun item
	command.item1, command.item1Parent = search(self, command.nouns[1], self.room)
	command.item2, command.item2Parent = search(self, command.nouns[2], self.room)

	-- Exits could point to things too, like doors.
	-- If there is no command item, attempt to find it using the
	-- direction value. The item will remain nil if it is not a thing.
	if command.verb == "go" and command.direction then
		if not command.item1 and self.room.exits then
			command.item1 = search(self, self.room.exits[command.direction], self.room)
		end
	end

	-- call any hooks for this command
	local hookSet, hookResponse = callHook(self, command)

	-- the hook has handled the request
	if hookSet then
		-- add a custom response if there is one
		if hookResponse then
			table.insert(self.responses, hookResponse)
		end
		-- stop further processing
		return command
	end

	-- include all items
	if commandRefersAll (self, command) then
		-- get list of children for item2, fall-back to the room.
		local children = listChildrenOf (self, command.item2 or self.room)
		for k, v in pairs (children) do
			if not v.isPlayer then
				-- "all" actions promotes the child of item2 to item1
				command.item1 = v
				apply (self, command)
			end
		end
	else
		apply (self, command)
		-- add a custom response if there is one
		-- TODO hooks obsoleted by rulebooks
		if hookResponse then
			table.insert(self.responses, hookResponse)
		end
	end

	referRulebook (self, self.rulebooks["after"], "turn")

	-- Increase the turn
	self.turnNumber = self.turnNumber + 1

	-- TODO return self.responses, command
	return command

end


--- Add a callback hook for any verb and noun combination.
-- If verb and noun match the parsed command it triggers the callback.
-- A nil noun matches any verb, while a nil verb is not allowed.
-- The callback should return a false to stop further turn processing.
-- @function hook
--
-- @param self
--
-- @param verb
-- The verb that triggers the hook.
--
-- @param noun
-- The noun that triggers the hook.
--
-- @param callback
-- The function to call when the hook is triggered.
--
-- TODO see hook example
local function hook (self, verb, noun, callback)

	if type(verb) == "nil" then
		error(string.format("No verb provided for the hook."), noun)
	end

	self.api.hooks[verb] = self.api.hooks[verb] or { }

	-- use default if noun is nil
	if type(noun) == "nil" then
		noun = "default"
	end

	self.api.hooks[verb][noun] = callback

end


--- Lists all the rulebooks and rules.
local function listRulebooks (self)
	for timing, collection in pairs(self.rulebooks) do
		for action, rules in pairs(collection) do
			print(string.format("The %s.%s book contains:", timing, action))
			for _, rule in ipairs(rules) do
				print(string.format("\tThe %s rule", rule.name))
			end
		end
	end
end


--- The moonlight instance.
-- @table instance
-- @field options The simulator @{options}
-- @field world A table of @{thing}s that make up the simulated world.
-- @field turn The @{turn} function.
-- @field hook The @{hook} function.
-- @field setPlayer The @{setPlayer} function.
-- @field responses The @{responses} table from the last @{turn}.
-- @field turnNumber The simulation turn number.
-- @field api The @{api} table.
return {
	options = options,
	template = templateResponses,
	turn = turn,
	hook = hook,
	responses = { },
	log = { },
	utils = utils,
	turnNumber = 1,
	rulebooks = standardRulebooks (),
	-- functions
	reset = reset,
	setWorld = setWorld,
	setPlayer = setPlayer,
	isCarrying = playerHas,
	moveItemInto = moveItemInto,
	moveItemOnto  = moveItemOnto,
	describe = describe,
	describeRoom = describeRoom,
	listRoomExits = listRoomExits,
	roomByName = roomByName,
	roomByDirection = roomByDirection,
	listInventory = listInventory,
	withArticle = withArticle,
	listRulebooks = listRulebooks,
	listContents = listContents,
	search = search,
	validate = require("world_validator"),

	--- Used internally.
	-- This table contains functions and other tables used by the
	-- simulator. It is exposed to provide access to unit testing of
	-- the simulator logic.
	-- @table api
	api = {
		searchGlobal  = searchGlobal , -- @{searchGlobal}
		parse = parse, -- @{parser.parse}
		playerHas = playerHas, -- @{playerHas}
		hooks = { }, -- The hooks as defined by @{hook}
	}
}
