

--- The moonlight interactive fiction simulator.
-- All functions are exported onto the module instance.
-- Local functions are used internally by the simulator and not meant
-- to be called directly, as such these are separated into a namespace.
-- @module moonlight

------------------------------------------------------------------------

--- A table of the parsed sentence, and world items that match any nouns.
-- @table command
--
-- @field verb
-- The verb word as interpreted by the parser.
-- It may mutate into a root word if the player input a synonym.
--
-- @field nouns
-- Indexed table of noun words parsed from the sentence.
-- It is not guaranteed these nouns match any items visible to the player.
--
-- @field direction
-- The word of the direction implied in the sentence.
--
-- @field item1
-- The world item (table) that matches the first of the nouns field.
-- If this has a value it is guaranteed to match an item in the world.
--
-- @field item2
-- The world item (table) that matches the second of the nouns field.
-- If this has a value it is guaranteed to match an item in the world.
--

------------------------------------------------------------------------

--- List of responses generated by a turn.
-- And example response is:
-- {"You take the envelope", "It feels like there is something heavy inside it"}
-- @table responses


------------------------------------------------------------------------

--- A table of options that define parser and response behavior.
-- @table options
--
-- @field verbs
-- Indexed table of words considered valid verbs.
-- If the player tries using a verb not in this list
-- then the defaultResponses.unknownVerb response is issued.
--
-- @field ignores
-- Indexed table of words to ignore when parsing a sentence.
-- These are words not considered verbs or nouns.
--
-- @field synonyms
-- Indexed table of tables of words. The first word is the root word and
-- following words are the synonyms. When a sentence is parsed all words
-- are replaced by their root equivalent.
--
-- @field vowels
-- Indexed table english vowels, used to generate noun articles when
-- describing or listing things.
--
-- @field directions
-- Indexed table of known directions.
--
-- TODO rest of the fields.
local options = {
	verbs = { "examine", "take", "drop", "attack", "inventory", "insert" },
	ignores = {"an", "a", "the", "for", "to", "at", "of", "with", "about", "on", "and"},
	synonyms = {
		{"attack", "hit", "smash", "kick", "cut", "kill"},
		{"insert", "put"},
		{"take", "get", "pick"},
		{"inventory", "i"},
		{"examine", "x", "l", "look"},
	},
	vowels = {"a", "e", "i", "o", "u"},
	directions = {
		"north", "n",
		"south", "s",
		"east", "e",
		"west", "w",
		"northeast", "ne",
		"southeast", "se",
		"northwest", "nw",
		"southwest", "sw",
		"up", "down", "in", "out"
		},
	roomLead = "There is %s here.",
	containerLead = "Inside it is %s.",
	supporterLead = "On it is %s.",
	defaultResponses = {
		fixedInPlace = "The %s is fixed in place.",
		thingNotSeen = "I don't see the %s.",
		takePerson = "%s wouldn't like that.",
		taken = "You take the %s.",
		alreadyHaveIt = "You already have it.",
		unknownVerb = "I don't know what %q means.",
		notContainer = "The %s cannot contain things.",
		dropped = "You drop the %s.",
		dontHaveIt = "You don't have the %s.",
		pocketsEmpty = "You are carrying nothing."
	}
}

--- Split a string.
local function split (s, delimiter)
    local result = { };
    for match in (s..delimiter):gmatch("(.-)"..delimiter) do
        table.insert(result, match);
    end
    return result;
end

--- Find a value in a table via a predicate function.
local function find (t, f)
	for k, v in pairs(t) do
		if f(k, v) then
			return v
		end
	end
	return nil
end

--- Filter a table by a predicate function.
local function filter (t, f)
	local matches = {}
	for k, v in pairs(t) do
		if f(k, v) then
			table.insert(matches, v)
		end
	end
	return matches
end

--- Get the index of a value in a table.
local function indexOf (t, cmp)
	for k, v in ipairs(t) do
		if v == cmp then
			return k
		end
	end
	return 0
end

--- Test if a table contains a value.
local function contains (t, cmp)
	return indexOf(t, cmp) > 0
end


--- Parse a sentence into a command object.
-- It extracts the verb and nouns from the sentence, and partially
-- input noun names are replaced by their full equivalent.
--
-- @param self
--
-- @param sentence
-- The sentence to parse.
--
-- @param known_nouns
-- Table of noun names to match partial noun names in the sentence.
--
-- @return @{command}
local function parse (self, sentence, known_nouns)

	-- Split the sentence into parts. Always work in lowercase.
	local parts = split(sentence:lower(), " ")

	-- Extract the direction.
	local function findDirectionFilter(k, v)
		return contains(self.options.directions, v)
	end

	local direction = find(parts, findDirectionFilter)

	-- Remove directions
	local function removeDirectionsFilter(k, v)
		return not contains(self.options.directions, v)
	end

	parts = filter(parts, removeDirectionsFilter)

	-- Remove ignored words
	local function removeIgnoresFilter(k, v)
		return not contains(self.options.ignores, v)
	end

	parts = filter(parts, removeIgnoresFilter)

	-- Replace any partial nouns with the known nouns.
	-- If a partial matches multiple known nouns, it will match the last one.
	if known_nouns then
		for partno, part in ipairs(parts) do
			for nounno, noun in ipairs(known_nouns) do
				-- if the part matches a known noun
				if string.match(noun, part) then
					-- replace the part with the match
					parts[partno] = noun
				end
			end
		end
	end

	-- Remove duplicates which can occur from the above step.
	local function removeDuplicatesFilter(k, v)
		return indexOf(parts, v) == k
	end

	parts = filter(parts, removeDuplicatesFilter)

	-- Extract the verb
	local verb = #parts > 0 and parts[1]

	-- Extract the nouns.
	local nouns = parts
	if #parts > 1 then
		-- remove the verb
		table.remove(nouns, 1)
	else
		nouns = { }
	end

	-- Change verbs to their root synonym.
	-- The first entry is the synonym list is the root word.
	for i, wl in ipairs(self.options.synonyms) do
		if contains(wl, verb) then
			verb = wl[1]
		end
	end

	-- TODO perform synonym check on direction

	return { verb=verb, nouns=nouns, direction=direction }

end


--- Finds the player in the world model.
local function findPlayer (self)

	if not self.world then
		error("The world is empty, you must set the world value first.")
	end

	for k, r in pairs(self.world) do

		local checklist = { }

		if type(r.contains) == "table" then
			for a, b in pairs(r.contains) do
				table.insert(checklist, b)
			end
		end

		while #checklist > 0 do

			local v = table.remove(checklist)

			if v.player == true then
				return v, r
			end

			if type(v.contains) == "table" then
				for a, b in pairs(v.contains) do
					table.insert(checklist, b)
				end
			end
			if type(v.supports) == "table" then
				for a, b in pairs(v.supports) do
					table.insert(checklist, b)
				end
			end

		end

	end

end


--- Search the world model for a thing.
-- @param self
--
-- @param term
-- The thing to search for, either by the name or by an instance of the
-- thing itself.
--
-- @param parent
-- The parent container to search within. Usually this is the current
-- room, but can also be the player for inventory checking, or any other
-- world item.
--
-- @param stack
-- Ignore this parameter, it is used to track the search progress
-- internally, and only given a value as part of the recursive function.
local function search (self, term, parent, stack)

	-- can search by name or by item
	local isItemSearch = type(term) == "table"

	-- init searched table stack
	stack = stack or { }
	local container = nil

	if type(parent.contains) == "table" and not stack[parent.contains] then
		--print(tostring(parent.name) .. " is a container")
		container = parent.contains
	elseif type(parent.supports) == "table" and not stack[parent.supports] then
		--print(tostring(parent.name) .. " is a supporter")
		container = parent.supports
	end

	if container then

		for i, v in ipairs(container) do
			if isItemSearch then
				if v == term then
					return v, parent, i
				end
			else
				if string.lower(tostring(v.name)) == term then
					--print("found " .. tostring(term) .. " in " .. tostring(parent.name) .. "!")
					return v, parent, i
				end
			end
		end

		for k, v in ipairs(container) do
			-- TODO this might cause bugs if the item is both a supporter and a container.
			-- stack only tracks the searched space for one of those cases.
			if not stack[v] and (type(v.contains) == "table" or type(v.supports) == "table") then
				--print("looking inside " .. tostring(v.name))
				stack[v] = true
				local resv, resp = search(self, term, v, stack)
				if resv then
					return resv, resp
				end
			end
		end

	end

end


--- Get the name of an item with the article prefixed.
local function withArticle (self, item)

	if item.person == true then
		return item.name
	end

	if item.article then
		return string.format("%s %s", item.article, item.name)
	end

	if indexOf(self.options.vowels, string.sub(item.name, 1, 1)) == 0 then
		return string.format("a %s", item.name)
	else
		return string.format("an %s", item.name)
	end

end


--- Joins an array of items to read naturally.
-- It joins a list of names with commas or "and" depending on how
-- many names are listed.
local function joinNames(self, names)

	if #names == 2 then
		return table.concat(names, " and ")
	elseif #names > 2 then
		local lastitem = table.remove(names)
		return table.concat(names, ", ") .. " and " .. lastitem
	else
		return table.concat(names)
	end

end


--- Describe the given item in detail.
-- The item's description is generated if it has none defined.
--
-- @param self
--
-- @param item
-- The item that will be described
--
-- @param leadFormat
-- The description format which can vary for rooms, supporters and containers.
--
-- @return string
local function describe (self, item, leadFormat)

	-- default item description if none is specified
	local desc = item.description or string.format("It is a %s.", item.name)

	-- list all the items contained in the item, or on top of the item.
	local items = { }
	local containerText = nil
	local supporterText = nil

	if type(item.contains) == "table" then
		for k, v in pairs(item.contains) do
			if not v.player then
				table.insert(items, withArticle(self, v))
			end
		end
		containerText = string.format(leadFormat or self.options.containerLead, joinNames(self, items))
	end

	-- clear items list for supporter listing
	items = { }

	-- list things on top of the item
	if type(item.supports) == "table" then
		for k, v in pairs(item.supports) do
			table.insert(items, withArticle(self, v))
		end
		supporterText = string.format(self.options.supporterLead, joinNames(self, items))
	end

	if containerText and supporterText then
		return string.format("%s %s %s", desc, containerText, supporterText)
	elseif containerText then
		return string.format("%s %s", desc, containerText)
	elseif supporterText then
		return string.format("%s %s", desc, supporterText)
	else
		return desc
	end

end


--- Lists items carried by the player.
-- @return string
local function listInventory (self)

	if #self.player.contains == 0 then
		return self.options.defaultResponses.pocketsEmpty
	end

	local items = { }

	for _, v in pairs(self.player.contains) do
		table.insert (items, withArticle (self, v))
	end

	return string.format ("You are carrying %s.", joinNames (self, items))

end


--- Move an item to another container.
-- TODO rename to insertItem and create a putItem for supporters.
local function moveItem (self, item, parent)

	if not type(parent) == "table" then
		error ("no parent specified to move item")
	end

	if type(parent.contains) ~= "table" then
		table.insert(self.responses, string.format(self.options.defaultResponses.notContainer, parent.name))
		return false
	end

	local match, oldparent, idx = search(self, item.name, self.room)

	if match and parent and oldparent then
		table.remove(oldparent.contains, idx)
		table.insert(parent.contains, match)
		return true
	end

end


--- Test if the player is carrying an item.
local function playerHas (self, item)

	return search(self, item, self.player) ~= nil

end


--- Take an item into the player's inventory.
-- Generates responses.
-- @return boolean
-- If the action succeeded.
local function tryTake (self, item)

	if item.person then
		table.insert(self.responses, string.format(self.options.defaultResponses.takePerson, item.name))
		return false
	end

	if item.fixed then
		table.insert(self.responses, string.format(self.options.defaultResponses.fixedInPlace, item.name))
		return false
	end

	if playerHas(self, item) then
		table.insert(self.responses, self.options.defaultResponses.alreadyHaveIt)
		return false
	end

	-- TODO space check

	if moveItem(self, item, self.player) == true then
		table.insert(self.responses, string.format(self.options.defaultResponses.taken, item.name))
		return true
	else
		return false
	end

end


--- Drop an item from the player's inventory.
-- @return boolean
-- If the action succeeded.
local function tryDrop (self, item)

	if not playerHas(self, item) then
		table.insert(self.responses, string.format(self.options.defaultResponses.dontHaveIt, item.name))
		return false
	end

	if moveItem(self, item, self.room) == true then
		table.insert(self.responses, string.format(self.options.defaultResponses.dropped, item.name))
		return true
	else
		return false
	end

end


--- Test if the command has no nouns.
-- @return boolean
local function commandMissingNouns (self, command)
	return #command.nouns == 0
end


--- Test if the command object has a noun-matched world item.
-- @return boolean
local function commandHasItem (self, command)
	if not command.item1 then
		if commandMissingNouns(self, command) then
			table.insert(self.responses, string.format("Be a little more specific what you want to %s.", command.verb))
			return false
		else
			table.insert(self.responses, string.format(self.options.defaultResponses.thingNotSeen, command.nouns[1]))
			return false
		end
	end
	return true
end


--- Increment the number of times a noun has been verbed.
local function countVerbUsedOnNoun (self, command)
	if command.item1 then
		command.item1.count = command.item1.count or { }
		command.item1.count[command.verb] = (command.item1.count[command.verb] or 0) + 1
	end
end

--- Apply a command to a world model.
-- This forwards the simulation by performing the command action against
-- the command nouns.
--
-- @return boolean
-- If the action succeeded.
local function apply (self, command)

	countVerbUsedOnNoun (self, command)

	if command.verb == "examine" then

		-- default to examining the room
		if commandMissingNouns(self, command) then
			table.insert(self.responses, describe(self, self.room, self.options.roomLead))
		elseif command.item1 then
			table.insert(self.responses, describe(self, command.item1))
		end

		return true

	elseif command.verb == "take" then
		if commandHasItem (self, command) then
			return tryTake (self, command.item1)
		end

	elseif command.verb == "drop" then
		if commandHasItem (self, command) then
			return tryDrop (self, command.item1)
		end

	elseif command.verb == "inventory" then
		table.insert(self.responses, listInventory(self))
		return true
	end

end


--- Calls a predefined hook that was defined by you, for the given
-- noun/verb combination of the command.
--
-- @param self
-- @param command
-- The @{command} object to check for hook existence.
local function callHook (self, command)

	-- Call any hooks for the verb and noun
	if type(self.api.hooks[command.verb]) == "table" then

		local noun = command.nouns[1]
		local hook = self.api.hooks[command.verb][noun]

		if type(hook) == "function" then
			return hook(self, command)
		end

	end

end


--- List the nouns in the current room.
-- Used to assist the parser in noun lookup.
local function listNouns (self)

	local checklist = { }
	local nounlist = { }

	for k, r in pairs(self.room.contains) do
		table.insert(checklist, r)
	end

	while #checklist > 0 do

		local v = table.remove(checklist)
		table.insert(nounlist, v.name)

		if type(v.contains) == "table" then
			for a, b in pairs(v.contains) do
				table.insert(checklist, b)
			end
		end
		if type(v.supports) == "table" then
			for a, b in pairs(v.supports) do
				table.insert(checklist, b)
			end
		end

	end

	return nounlist

end


--- Process the player's turn.
-- The sentence is parsed into actionable verbs and nouns, those are
-- applied to the world model and a response is generated.
--
-- @function turn
--
-- @param self The moonlight instance.
--
-- @param sentence The input sentence that is parsed into actions.
--
-- @return @{responses}, @{command}
local function turn (self, sentence)

	-- Clear the previous turn responses
	self.responses = { }

	self.player, self.room = findPlayer(self)

	-- TODO: boil the room down
	-- copy the room object but only include items visible.
	-- do not mutate the original room contents.

	if self.player == nil then
		error("I could not find a player in the world. They should have the \"player\" value of true.")
	end

	-- list of known nouns from the current room
	local known_nouns = listNouns(self)

	-- Parse the sentence
	local command = parse (self, sentence, known_nouns)

	-- Do we understand the verb?
	if not contains (self.options.verbs, command.verb) then
		table.insert(self.responses, string.format(self.options.defaultResponses.unknownVerb, command.verb))
		return false
	end

	-- look up each noun item
	command.item1, command.item1Parent = search(self, command.nouns[1], self.room)
	command.item2, command.item2Parent = search(self, command.nouns[2], self.room)

	-- call any hooks for this command
	local hookSet, hookResponse = callHook(self, command)

	-- the hook has handled the request
	if hookSet then
		-- add a custom response if there is one
		if hookResponse then
			table.insert(self.responses, hookResponse)
		end
		-- stop further processing
		return false
	end

	-- Apply the command to the model
	local commandResult = apply (self, command)

	if commandResult == true then

		-- add a custom response if there is one
		if hookResponse then
			table.insert(self.responses, hookResponse)
		end

		-- Increase the turn
		self.turnNumber = self.turnNumber + 1

	end

	-- TODO return self.responses, command
	return command

end


--- Add a callback hook for any verb and noun combination.
-- If verb and noun match the parsed command it triggers the callback.
-- A nil noun matches any verb, while a nil verb is not allowed.
-- The callback should return a false to stop further turn processing.
-- @function hook
--
-- @param self
--
-- @param verb
-- The verb that triggers the hook.
--
-- @param noun
-- The noun that triggers the hook.
--
-- @param callback
-- The function to call when the hook is triggered.
--
-- TODO see hook example
local function hook (self, verb, noun, callback)

	if type(verb) == "nil" then
		error(string.format("No verb provided for the hook."), noun)
	end

	self.api.hooks[verb] = self.api.hooks[verb] or { }

	-- use default if noun is nil
	if type(noun) == "nil" then
		noun = "default"
	end

	self.api.hooks[verb][noun] = callback

end

--- The moonlight instance.
-- @table instance
-- @field options The simulator @{options}
-- @field turn The @{turn} function.
-- @field hook The @{hook} function.
-- @field responses The @{responses} table from the last @{turn}.
-- @field turnNumber The simulation turn number.
-- @field api The @{api} table.
return {
	options = options,
	turn = turn,
	hook = hook,
	-- TODO set player method
	responses = { },
	turnNumber=1,
	--- Used internally.
	-- This table contains functions and other tables used by the
	-- simulator. It is exposed to provide access to unit testing of
	-- the simulator logic.
	-- @table api
	api = {
		search = search, -- The @{search} function
		parse = parse, -- The @{parse} function
		playerHas = playerHas, -- The @{playerHas} function
		hooks = { }, -- The hooks as defined by the @{hook} function
	}
}
